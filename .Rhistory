for (i in 1:rows) {
for (j in 1:cols) {
expect[i,j] <- (Table[i,cols + 1] * Table[rows + 1, j]) / Table[rows + 1, cols + 1]
}
}
ta_expected <- expect
}
cells <- ta_chi_square_cell_values(ObsidianTable)
ta_expected <- function(Table) {
Table <- ta_add_totals(Table)
expect <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
expect[i,j] <- (Table[i,cols + 1] * Table[rows + 1, j]) / Table[rows + 1, cols + 1]
}
}
ta_expected <- expect
}
expected <- ta_expected(ObsidianTable)
expected
ta_chi_square_cell_values <- function(Table) {
expected <- ta_expected(Table)
cell_values <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
cell_values[i,j] <- ((Table[i,j] - expected[i,j]) * (Table[i,j] - expected[i,j])) / expected[i,j]
}
}
ta_chi_square_cell_values <- cell_values
}
X <- ta_chi_square(ObsidianTable)
X
ta_chi_square_cell_values <- function(Table) {
expected <- ta_expected(Table)
cell_values <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
cell_values[i,j] <- ((Table[i,j] - expected[i,j]) * (Table[i,j] - expected[i,j])) / expected[i,j]
}
}
ta_chi_square_cell_values <- cell_values
}
ta_add_totals <- function (Table) {
rows <- nrow(Table)
cols <- ncol(Table)
row_total <- vector(mode = "numeric", rows)
column_total <- vector(mode = "numeric", cols + 1)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
for (i in 1:cols){
column_total[i] <- sum(Table[1:rows, i])
}
column_total[rows+1] <- sum(column_total)
Table <- cbind(Table,row_total)
ta_add_totals <- rbind(Table,column_total)
}
library(TableAnalysis)
library(TableAnalysis)
ta_chi_square(Obsidian)
load(Obsidian)
load(ObsidianTable)
load("C:/Users/jra64/Documents/TableAnalysis/data/Obsidian.RData")
View(ObsidianTable)
View(ObsidianTable)
Obsidian <- ObsidianTable
save(Obsidian, file = "Obsidian.RData")
load(Obsidian)
load(Obsidian)
load("Obsidian.RData")
library(TableAnalysis)
view(Obsidian)
view(Obsidian)
ta_chi_square(Obsidian)
ta_chi_square(Obsidian)
ta_chi_square(ObsidianTable)
library(TableAnalysis)
ta_chi_square(ObsidianTable)
X <- ta_chi_square(ObsidianTable)
X
X <- ta_chi_square(ObsidianTable)
X <- ta_chi_square(Obsidian)
library(TableAnalysis)
ta_chi_square(Obsidian)
X <- ta_chi_square(Obsidian)
X
ta_Cramers_V(Obsidian)
V <- ta_Cramers_V(Obsidian)
V
library(TableAnalysis)
library(TableAnalysis)
t <- ta_expected(Obsidian)
t
names(t) <- names(Obsidian)
t
names(t)
names(obsidian)
force(Obsidian)
names(obsidian)
o <- data("Obsidian")
View(t)
force(Obsidian)
data(Obsidian)
force(Obsidian)
e <- ta_expected(Obsidian)
names(e) <- names(Obsidian)
names(e)
names(Obsidian)
str(Obsidian)
dimnames(Obsidian)
dimnames(e) <- dimnames(Obsidian)
e
View(Obsidian)
View(Obsidian)
View(e)
View(e)
dimnames(Obsidian) <- chr [1:4] "Black Rock" "Topaz" "Wildhorse Canyon" "Northern Sources"
colnames(Obsidian)
colnames(Obsidian) <- c("Woodard Mound Debitage" "Woodard Mound Tools"    "Wolf Village Debitage"  "Wolf Village Tools" )
colnames(Obsidian) <- c("Woodard Mound Debitage", "Woodard Mound Tools", "Wolf Village Debitage", "Wolf Village Tools" )
rownames(Obsidian)
rownames(Obsidian) <- c( "Black Rock", "Topaz", "Wildhorse Canyon", "Northern Sources")
Obsidian
save(Obsidian, file = "Obsidian.RData")
library(TableAnalysis)
data(Obsidian)
force(Obsidian)
library(TableAnalysis)
data(Obsidian)
force(Obsidian)
tots <- ta_add_totals(Obsidian)
tots
e <- ta_expected(Obsidian)
e
ta_expected <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
totals <- ta_add_totals(Table)
expect <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
expect[i,j] <- (totals[i,cols + 1] * totlas[rows + 1, j]) / totals[rows + 1, cols + 1]
}
}
ta_expected <- expect
}
e <- ta_expected(Obsidian)
ta_expected <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
totals <- ta_add_totals(Table)
expect <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
expect[i,j] <- (totals[i,cols + 1] * totals[rows + 1, j]) / totals[rows + 1, cols + 1]
}
}
ta_expected <- expect
}
e <- ta_expected(Obsidian)
e
ta_expected <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
totals <- ta_add_totals(Table)
expect <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
expect[i,j] <- (totals[i,cols + 1] * totals[rows + 1, j]) / totals[rows + 1, cols + 1]
}
}
dimnames(expect) <- dimnames(Table)
ta_expected <- expect
}
e <- ta_expected(Obsidian)
e
cells <- ta_chi_square_cell_values(Obsidian)
cells
ta_chi_square_cell_values <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
expected <- ta_expected(Table)
cell_values <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
cell_values[i,j] <- ((Table[i,j] - expected[i,j]) * (Table[i,j] - expected[i,j])) / expected[i,j]
}
}
dimnames(cell_values) <- dimnames(Table)
ta_chi_square_cell_values <- cell_values
}
cells <- ta_chi_square_cell_values(Obsidian)
cells
library(TableAnalysis)
ta_chi_square_cell_values(Obsidian)
c <- ta_chi_square_cell_values(Obsidian)
c
c <- ta_chi_square_cell_values(Obsidian)
?options()
options(digits = 2)
c
options(digits = 1)
c
options(digits = 10)
c
round(c,2)
round(c,1)
ta_chi_square(Obsidian)
X <- ta_chi_square(Obsidian)
X
round(X,1)
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
ta_chi_square <- sum(row_total)
p <- 1 - pchisq(ta_chi_square, ((rows-1)*(cols-1)))
}
X <- ta_chi_square(Obsidian)
write("chi-square = ",ta_chi_square, "p = ", p)
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
ta_chi_square <- sum(row_total)
p <- 1 - pchisq(ta_chi_square, ((rows-1)*(cols-1)))
write("chi-square = ",ta_chi_square, "p = ", p)
}
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
ta_chi_square <- sum(row_total)
p <- 1 - pchisq(ta_chi_square, ((rows-1)*(cols-1)))
write("chi-square = ",ta_chi_square, "p = ", p)
}
X <- ta_chi_square(Obsidian)
X <- ta_chi_square(Obsidian)
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
X <- sum(row_total)
p <- 1 - pchisq(X, ((rows-1)*(cols-1)))
ta_chi_square <- X
}
X <- ta_chi_square(Obsidian)
X
write("chi-square = ",ta_chi_square, "p = ", p)
write("chi-square = ", X, "p = ", p)
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
X <- sum(row_total)
p <- 1 - pchisq(X, ((rows-1)*(cols-1)))
ta_chi_square <- X
}
write("chi-square = ", X, "p = ", p)
X <- ta_chi_square(Obsidian)
write("chi-square = ", X)
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
X <- sum(row_total)
p <- 1 - pchisq(X, ((rows-1)*(cols-1)))
ta_chi_square <- X
}
result <- X
X <- ta_chi_square(Obsidian)
X
F <- ta_chi_square(Obsidian)
F
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
X <- sum(row_total)
p <- 1 - pchisq(X, ((rows-1)*(cols-1)))
return("X-square = ", X, "P = ", p)
}
F <- ta_chi_square(Obsidian)
X <- sum(row_total)
ta_chi_square <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
Table <- ta_chi_square_cell_values(Table)
row_total <- vector(mode = "numeric", rows)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
X <- sum(row_total)
return(X)
}
h <- ta_chi_square(Obsidian)
h
ta_add_totals <- function (Table) {
rows <- nrow(Table)
cols <- ncol(Table)
row_total <- vector(mode = "numeric", rows)
column_total <- vector(mode = "numeric", cols + 1)
for (i in 1:rows) {
row_total[i] <- sum(Table[i,1:cols])
}
for (i in 1:cols){
column_total[i] <- sum(Table[1:rows, i])
}
column_total[rows+1] <- sum(column_total)
Table <- cbind(Table,row_total)
return(rbind(Table,column_total))
}
t <- ta_add_totals(Obsidian)
t
ta_chi_square_cell_values <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
expected <- ta_expected(Table)
cell_values <- array(dim = c(rows,cols))
for (i in 1:rows) {
for (j in 1:cols) {
cell_values[i,j] <- ((Table[i,j] - expected[i,j]) * (Table[i,j] - expected[i,j])) / expected[i,j]
}
}
dimnames(cell_values) <- dimnames(Table)
return(cell_values)
}
c <- ta_chi_square_cell_values(Obsidian)
c
ta_Cramers_V <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
chisq <- ta_chi_square(Table)
Table_with_Totals <- ta_add_totals(Table)
Grand_Total <- Table_with_Totals[rows+1,cols+1]
return(round(sqrt(chisq/(Grand_Total*min(rows-1,cols-1))),3))
}
cv <- ta_Cramers_V(Obsidian)
cv
ex <- ta_expected(Obsidian)
ex
round(ex,3)
round(ex,1)
ta_p_value <- function(X, df) {
p <- 1 - pchisq(X,df)
return p
}
ta_p_value <- function(X, df) {
p <- 1 - pchisq(X,df)
return p
}
ta_p_value <- function(X, df) {
p <- 1 - pchisq(X,df)
return(p)
}
x <- ta_chi_square(Obsidian)
x
ta_chisq_p <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
x <- ta_chi_square(Table)
df <- (rows - 1) * (cols - 1)
p <- 1 - pchisq(x,df)
return(p)
}
ta_chisq_p(Obsidian)
ta_chi_square(Obsidian)
ta_chisq_p <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
x <- ta_chi_square(Table)
df <- (rows - 1) * (cols - 1)
p <- round(1 - pchisq(x,df),3)
return(p)
}
ta_chisq_p(Obsidian)
ta_chisq_p <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
x <- ta_chi_square(Table)
df <- (rows - 1) * (cols - 1)
p <- (1 - pchisq(x,df))
options(digits = 3)
return(p)
}
ta_chisq_p(Obsidian)
ta_chisq_p <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
x <- ta_chi_square(Table)
df <- (rows - 1) * (cols - 1)
p <- (1 - pchisq(x,df))
options(digits = 3, scipen = 10)
return(p)
}
ta_chisq_p(Obsidian)
ta_chisq_p <- function(Table) {
rows <- nrow(Table)
cols <- ncol(Table)
x <- ta_chi_square(Table)
df <- (rows - 1) * (cols - 1)
p <- (1 - pchisq(x,df))
options(digits = 3, scipen = 999)
return(p)
}
ta_chisq_p(Obsidian)
ta_chi_square(Obsidian)
library(TableAnalysis)
ta_chi_square(Obsidian)
ta_expected(Obsidian)
ta_chi_square_cell_values(Obsidian)
ta_Cramers_V(Obsidian)
ta_expected(Obsidian)
ta_chisq_p(Obsidian)
library(tidyverse)
+ facet_grid(. ~ cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(. ~ cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(drv ~ .)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(drv ~ cyl)
library(Bowls)
boxplot(BowlData, BowlData$Ware, BowlData$Rim.Diameter)
library(tidyverse)
boxplot(BowlData, BowlData$Ware, BowlData$Rim.Diameter)
Data(BowlData)
data(BowlData)
library(leastcostpath)
library(sf)
library(elevatr)
library(spdep)
#store projection information as a string (UTM Zone 12)
prj_dd <- "+proj=utm +zone=12 +ellps=WGS84 +datum=NAD83 +no_defs"
x <- c(612000, 613000, 614000, 612000, 611250, 612250)
y <- c(4162000, 4162000, 4162000, 4160000, 4159500, 4159500)
locs <- SpatialPoints(cbind(x,y), proj4string = CRS(prj_dd))
DEM <- get_elev_raster(locs, z = 14)
plot(DEM)
plot(locs, pch = 19, col = "red", add = TRUE)
#create cost-surface from DEM using Tobler hiking function
#changing the number of neighbors had little effect on the costs (correlations were all ca..99); max_slope = 54 is the highest value that prevents all the paths in the test data from crossing the canyon
slope_cs4 <- create_slope_cs(DEM, cost_function = 'tobler', neighbours = 4, max_slope = 54)
ToFrom <- cbind(c(rep(1,6), rep(2,6), rep(3,6), rep(4,6), rep(5,6), rep(6,6)), c(rep(1:6,6)))
lcp_network <- create_lcp_network(slope_cs4, locations = locs, nb_matrix = ToFrom, cost_distance = TRUE)
plot(lcp_network, add = TRUE)
lcp_network@data
dist <- spDists(locs, locs, longlat = FALSE)
meters <- append(dist[,1], dist[,2:ncol(dist)])
Distances <- cbind(lcp_network@data, meters)
Distances <- Distances[which(meters > 0),]
minutes <- Distances$cost / 60
Distances <- cbind(Distances, minutes)
plot(Distances$meters, Distances$minutes, pch = 19)
DEM <- get_elev_raster(locs, z = 13)
plot(DEM)
plot(locs, pch = 19, col = "red", add = TRUE)
#create cost-surface from DEM using Tobler hiking function
#changing the number of neighbors had little effect on the costs (correlations were all ca..99); max_slope = 54 is the highest value that prevents all the paths in the test data from crossing the canyon
slope_cs4 <- create_slope_cs(DEM, cost_function = 'tobler', neighbours = 4, max_slope = 54)
ToFrom <- cbind(c(rep(1,6), rep(2,6), rep(3,6), rep(4,6), rep(5,6), rep(6,6)), c(rep(1:6,6)))
lcp_network <- create_lcp_network(slope_cs4, locations = locs, nb_matrix = ToFrom, cost_distance = TRUE)
plot(lcp_network, add = TRUE)
lcp_network@data
dist <- spDists(locs, locs, longlat = FALSE)
meters <- append(dist[,1], dist[,2:ncol(dist)])
Distances <- cbind(lcp_network@data, meters)
Distances <- Distances[which(meters > 0),]
minutes <- Distances$cost / 60
Distances <- cbind(Distances, minutes)
plot(Distances$meters, Distances$minutes, pch = 19)
library(TableAnalysis)
#install.packages("devtools")
library(devtools)
install_github("josephlewis/leastcostpath")
library(leastcostpath)
library(sf)
library(elevatr)
detach("package:leastcostpath", unload = TRUE)
install_github("josephlewis/leastcostpath")
install_github("josephlewis/leastcostpath", force = TRUE)
